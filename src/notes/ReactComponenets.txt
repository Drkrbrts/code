So you are unable to pass arguments to functions inside of onClick therefore, 
whenever you want to passs arguments you would have to do it like this:

say you want an even in regards to some products ID then you would do this 


incrementCount = (product) => {
    // console.log("button is firing: ", this.state.count);
    this.setState({ count: this.state.count + 1 });
  };


  <button
          className="btn btn-secondary btn-sm"
          type="submit"
          onClick={()=> this.incrementCount(product.id)} //an anonymous call back function.
        >
          Increment
        </button>


lets use filter to delete items.
ex: 

handleDelete = Movie => {
    const movies = this.state.movies.filter(m => m._id !== movie._id);
    this.setState({movies});
};









find a way to put props into state and chnage it via state if you have to? at minute 33:00 in video
passing state and functions to children


state updates may be asynchronous there 

react may batch multple setState() calls into a single update for performance. 

Because this.props and this.state may be updated asynchronously, you should not rely on values for calculating 
the next state. 

for example 



state updates are merged 

-if you have mulple varibles in your state object you should call seperate setState methods if you
need to update them both. 
say you have a state ={
  posts:[],
  comments:[]
}

setState for posts and setState for ocmments 

top down data flow 
Neither parent nor child components can know if a certain component is stateful or stateless, 
and they shouldn’t care whether it is defined as a function or a class.

This is why state is often called local or encapsulated. It is not accessible to any component
 other than the one that owns and sets it.

 The FormattedDate component would receive the date in its props and wouldn’t know whether 
 it came from the Clock’s state, from the Clock’s props, or was typed by hand:



and any data or UI derived from that state can only affect components “below”
\ them in the tree

We recommend naming props from the component’s own point of view rather than the context in which it 
is being used.

Extracting components might seem like grunt work at first, but having a palette of reusable components pays 
off in larger apps. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, 
Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be extracted 
to a separate component.


// This binding is necessary to make `this` work in the callback
    this.handleClick = this.handleClick.bind(this);


  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}

You have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not 
bound by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined 
when the function is actually called. This is not React-specific behavior; it is a part of how functions 
work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, 
you should bind that method. If calling bind annoys you, there are two ways you can get around this. 
If you are using the experimental public class fields syntax, you can use class fields to correctly bind 
callbacks:

 This syntax is enabled by default in Create React App.

If you aren’t using class fields syntax, you can use an arrow function in the callback:


 handleClick() {
    console.log('this is:', this);
  }

  render() {
    // This syntax ensures `this` is bound within handleClick
    return (
      <button onClick={() => this.handleClick()}>
        Click me
      </button>
    );
  }
}


The problem with this syntax is that a different callback is created each time the LoggingButton renders. 
In most cases, this is fine. However, if this callback is passed as a prop to lower components, 
those components might do an extra re-rendering. We generally recommend binding in the constructor or 
using the class fields syntax, to avoid this sort of performance problem.


Passing arguments to the event handlers 

inside a loop , it is common to want to pass an extra parameter to an event hadnler. For example
, if ID is the row ID, either of the following would work:

<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>

In both cases, the e argument representing the React event will be passed as a second argument after the ID.
 With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically 
 forwarded.